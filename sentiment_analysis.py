# -*- coding: utf-8 -*-
"""Sentiment analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D-MrF08Dv1DIDcV-zha-kgssq5ufdDod
"""

# taking data from kaggle, uploading file on drive and viewing file
import pandas as pd
import numpy as np
df = pd.read_table("/content/Restaurant_Reviews.tsv")
df

"""**Data Visualization**"""

#Data Visualization
import matplotlib.pyplot as plt
likes = df.Liked

likes.unique() # types of likes (1 and 0 were result of this command)

size = df.groupby('Liked',sort=False).size() 
size

plt.bar(likes.unique(), size)

df['Liked'].value_counts() # no of 1's and 0's

"""**Creating SVC model and Count Vectorizer seperatelyt**

"""

# Train_Test_Split
x = df['Review'].values
y = df['Liked'].values

from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test = train_test_split(x,y,random_state=0)

# count vectorizer
from sklearn.feature_extraction.text import CountVectorizer
vect = CountVectorizer(stop_words = 'english')
x_train_vect = vect.fit_transform(x_train) 
x_test_vect = vect.transform(x_test)

# Creating SVC model
from sklearn.svm import SVC
model1 = SVC()
model1.fit(x_train_vect,y_train)

y_pred = model1.predict(x_test_vect)
y_pred

y_test

from sklearn.metrics import accuracy_score
accuracy_score(y_pred,y_test)

"""**USING SVC + PIPELINE**"""

from sklearn.pipeline import make_pipeline 
model2 = make_pipeline(CountVectorizer(),SVC())

model2.fit(x_train,y_train)

y_pred1 = model2.predict(x_test)
y_pred1

from sklearn.metrics import accuracy_score
accuracy_score(y_pred1,y_test)

"""As of yet, Accuracy for SVC = **72%**
           Accuracy for SVC + pipeline = **79.2%**

**METHOD 2 -** USING Naive BAYES
"""

from sklearn.naive_bayes import MultinomialNB
model3 = MultinomialNB()
model3.fit(x_train_vect,y_train)

y_pred2 = model3.predict(x_test_vect)
y_pred2

y_test

accuracy_score(y_pred2,y_test)
0.794

"""**USING NB + PIPELINE**"""

from sklearn.pipeline import make_pipeline
model4 = make_pipeline(CountVectorizer(),MultinomialNB())
model4.fit(x_train,y_train)
y_pred3 = model4.predict(x_test)
y_pred3

accuracy_score(y_pred3,y_test)

"""**ACCURACY FOR SVC = 72%** *italicized text*
**ACCURACY FOR NB = 79.4%** *italicized text*

**ACCURACY FOR SVC + PIPELINE = 74.4%** *italicized text*
**ACCURACY FOR NB + PIPELINE = 78.4%** *italicized text*

USING **JOBLIB** TO SAVE AS MODEL

> Indented block
"""

import joblib
joblib.dump(model2,'Sentiment') # using model 2

"""**USING NEW MODEL TO PREDICT OUTPUT**"""

import joblib 
reload_model = joblib.load('Sentiment')

#predict using the reloaded joblib model 
reload_model.predict(["The food was too salty!"])

"""**Using Streamlit to create web app and predict output**"""

#install streamlit 
!pip install streamlit --quiet

# Commented out IPython magic to ensure Python compatibility.
# #STREAMLIT WEBAPP 
# %%writefile app.py 
# import streamlit as st  #webapp framework/library 
# import joblib 
# 
# reload_model = joblib.load('Sentiment')  #loads the joblib model 
# 
# st.title("Review predictor")
# st.write("USING PIPELINE MODELS")
# ip = st.text_input("Enter your message:") #asking the user input 
# 
# #predict if the entered message is spam or ham 
# 
# op = reload_model.predict([ip])  #predict the output 
# if st.button('PREDICT'): #if button is clicked 
#   st.title(op[0]) #prints the output in single dimension

# running the app 
!streamlit run app.py & npx localtunnel --port 8501